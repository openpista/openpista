use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Definition of a tool that can be called by the LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolDefinition {
    /// Unique tool name used in tool calls.
    pub name: String,
    /// Human-readable tool description for model guidance.
    pub description: String,
    /// JSON Schema describing tool arguments.
    pub parameters: serde_json::Value,
}

impl ToolDefinition {
    /// Builds a tool definition.
    pub fn new(
        name: impl Into<String>,
        description: impl Into<String>,
        parameters: serde_json::Value,
    ) -> Self {
        Self {
            name: name.into(),
            description: description.into(),
            parameters,
        }
    }
}

/// A tool call request from the LLM
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ToolCall {
    /// Unique call id (generated by caller or model bridge).
    pub id: String,
    /// Target tool name.
    pub name: String,
    /// JSON arguments object.
    pub arguments: serde_json::Value,
}

impl ToolCall {
    /// Creates a tool call with a random call id.
    pub fn new(name: impl Into<String>, arguments: serde_json::Value) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            name: name.into(),
            arguments,
        }
    }
}

/// Result of executing a tool call
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolResult {
    /// Call id this result belongs to.
    pub call_id: String,
    /// Tool name that produced this result.
    pub tool_name: String,
    /// Output payload text.
    pub output: String,
    /// Whether this result is an error.
    pub is_error: bool,
}

impl ToolResult {
    /// Creates a successful tool execution result.
    pub fn success(
        call_id: impl Into<String>,
        tool_name: impl Into<String>,
        output: impl Into<String>,
    ) -> Self {
        Self {
            call_id: call_id.into(),
            tool_name: tool_name.into(),
            output: output.into(),
            is_error: false,
        }
    }

    /// Creates an error tool execution result.
    pub fn error(
        call_id: impl Into<String>,
        tool_name: impl Into<String>,
        error: impl Into<String>,
    ) -> Self {
        Self {
            call_id: call_id.into(),
            tool_name: tool_name.into(),
            output: error.into(),
            is_error: true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tool_definition_new_assigns_fields() {
        let params = serde_json::json!({"type":"object"});
        let def = ToolDefinition::new("system.run", "run command", params.clone());

        assert_eq!(def.name, "system.run");
        assert_eq!(def.description, "run command");
        assert_eq!(def.parameters, params);
    }

    #[test]
    fn tool_call_new_generates_id() {
        let call = ToolCall::new("system.run", serde_json::json!({"command":"echo hi"}));
        assert_eq!(call.name, "system.run");
        assert_eq!(call.arguments["command"], "echo hi");
        assert!(!call.id.is_empty());
    }

    #[test]
    fn tool_result_success_sets_non_error_flag() {
        let result = ToolResult::success("c1", "system.run", "ok");
        assert_eq!(result.call_id, "c1");
        assert_eq!(result.tool_name, "system.run");
        assert_eq!(result.output, "ok");
        assert!(!result.is_error);
    }

    #[test]
    fn tool_result_error_sets_error_flag() {
        let result = ToolResult::error("c2", "system.run", "boom");
        assert_eq!(result.call_id, "c2");
        assert_eq!(result.tool_name, "system.run");
        assert_eq!(result.output, "boom");
        assert!(result.is_error);
    }
}
