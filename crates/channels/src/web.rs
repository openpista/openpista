//! Web channel adapter — axum HTTP server with WebSocket support.
//!
//! Provides a WebSocket-based channel for browser clients, served alongside
//! static H5 chat assets from a configurable directory.

use async_trait::async_trait;
use axum::{
    Json, Router,
    extract::{Path, Query, State, WebSocketUpgrade, ws},
    http::StatusCode,
    response::{IntoResponse, Redirect},
    routing::get,
};
use chrono::{DateTime, Duration as ChronoDuration, Utc};
use dashmap::DashMap;
use futures_util::{SinkExt, StreamExt};
use proto::{AgentMessage, AgentResponse, ChannelError, ChannelEvent, ChannelId, Role, SessionId};
use rand::RngCore;
use serde::{Deserialize, Serialize};
use std::sync::{Arc, RwLock};
use tokio::sync::{broadcast, mpsc};
use tower_http::cors::{Any, CorsLayer};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::adapter::ChannelAdapter;

// ─── WsMessage envelope ────────────────────────────────────

/// WebSocket message envelope for client-server communication.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WsMessage {
    /// Browser requests the latest session list from server memory.
    #[serde(rename = "sessions_request")]
    SessionsRequest,
    /// Server sends TUI-sourced session list to browser.
    #[serde(rename = "sessions_list")]
    SessionsList {
        /// Snapshot of current sessions, aligned with TUI source.
        sessions: Vec<WebSessionEntry>,
    },
    /// Client sends a chat message.
    #[serde(rename = "message")]
    UserMessage {
        /// User-authored text content.
        content: String,
        /// Optional message id generated by the browser for diagnostics.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        message_id: Option<String>,
    },
    /// Server sends an agent response.
    #[serde(rename = "response")]
    AgentReply {
        /// Response text generated by the agent.
        content: String,
        /// Whether the response represents an error.
        is_error: bool,
    },
    /// Server acknowledges that a client message has been queued.
    #[serde(rename = "message_ack")]
    MessageAck {
        /// Optional client-generated message id.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        message_id: Option<String>,
        /// Effective session id used for this message.
        session_id: String,
    },
    /// Server reports an enqueue/send error for a client message.
    #[serde(rename = "message_error")]
    MessageError {
        /// Optional client-generated message id.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        message_id: Option<String>,
        /// Effective session id used for this message.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        session_id: Option<String>,
        /// Human-readable error detail.
        error: String,
    },
    /// Client requests full conversation history for a session.
    #[serde(rename = "session_history_request")]
    SessionHistoryRequest {
        /// Session id whose history is requested.
        session_id: String,
    },
    /// Server sends full conversation history for a session.
    #[serde(rename = "session_history")]
    SessionHistory {
        /// Session id this history belongs to.
        session_id: String,
        /// Ordered list of messages (oldest first).
        messages: Vec<WebHistoryMessage>,
    },
    /// Heartbeat ping from client.
    #[serde(rename = "ping")]
    Ping,
    /// Heartbeat pong from server.
    #[serde(rename = "pong")]
    Pong,
    /// Authentication request from client.
    #[serde(rename = "auth")]
    Auth {
        /// Authentication token supplied by the browser client.
        token: String,
    },
    /// Authentication result from server.
    #[serde(rename = "auth_result")]
    AuthResult {
        /// `true` when authentication succeeds.
        success: bool,
        /// Stable client identifier assigned by the server.
        client_id: Option<String>,
        /// Error message when authentication fails.
        error: Option<String>,
        /// Active provider name selected by the daemon.
        provider: Option<String>,
        /// Active model id selected by the daemon.
        model: Option<String>,
        /// Effective session id bound to this WebSocket connection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        session_id: Option<String>,
        /// `true` when session is shared with TUI default session.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        shared_with_tui: Option<bool>,
    },
    /// Client requests available model list.
    #[serde(rename = "model_list_request")]
    ModelListRequest,

    /// Server sends available model list.
    #[serde(rename = "model_list")]
    ModelList {
        /// Available models grouped by provider.
        models: Vec<WebModelEntry>,
    },

    /// Client requests a model change.
    #[serde(rename = "model_change")]
    ModelChange {
        /// Target provider name.
        provider: String,
        /// Target model id.
        model: String,
    },

    /// Server confirms model change.
    #[serde(rename = "model_changed")]
    ModelChanged {
        /// New active provider.
        provider: String,
        /// New active model.
        model: String,
    },

    /// Client requests provider auth status list.
    #[serde(rename = "provider_auth_request")]
    ProviderAuthRequest,

    /// Server sends provider auth status list.
    #[serde(rename = "provider_auth_status")]
    ProviderAuthStatus {
        /// Available providers with auth status.
        providers: Vec<WebProviderAuthEntry>,
    },

    /// Client requests provider login (OAuth, API key, or code completion).
    #[serde(rename = "provider_login")]
    ProviderLogin {
        /// Target provider name.
        provider: String,
        /// Optional API key for direct-key providers.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        api_key: Option<String>,
        /// Optional endpoint URL for endpoint+key providers.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        endpoint: Option<String>,
        /// Optional authorization code for code-display OAuth flows.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        auth_code: Option<String>,
    },

    /// Server sends OAuth auth URL for the client to open.
    #[serde(rename = "provider_auth_url")]
    ProviderAuthUrl {
        /// Provider name this URL belongs to.
        provider: String,
        /// Full authorization URL to open in a browser window.
        auth_url: String,
        /// Flow type: "redirect" for localhost callback, "code_display" for code input.
        flow_type: String,
    },

    /// Server confirms provider auth completed.
    #[serde(rename = "provider_auth_completed")]
    ProviderAuthCompleted {
        /// Provider name that completed authentication.
        provider: String,
        /// Whether authentication succeeded.
        success: bool,
        /// Human-readable result message.
        message: String,
    },

    /// Client requests cancellation of current agent processing.
    #[serde(rename = "cancel_generation")]
    CancelGeneration,

    /// Server confirms generation was cancelled.
    #[serde(rename = "generation_cancelled")]
    GenerationCancelled,

    /// Server requests tool call approval from the client.
    #[serde(rename = "tool_approval_request")]
    ToolApprovalRequest {
        /// Tool-call identifier from the LLM.
        call_id: String,
        /// Name of the tool to be executed.
        tool_name: String,
        /// JSON arguments for the tool call.
        arguments: serde_json::Value,
    },

    /// Client sends tool call approval decision.
    #[serde(rename = "tool_approval_response")]
    ToolApprovalResponse {
        /// Tool-call identifier this decision applies to.
        call_id: String,
        /// Decision: "approve", "reject", or "allow_for_session".
        decision: String,
    },
}

/// Callback type for model change requests from web clients.
pub type ModelChangeCallback = Arc<dyn Fn(String, String) + Send + Sync>;

/// Callback returning provider auth status list.
pub type ProviderListCallback = Arc<dyn Fn() -> Vec<WebProviderAuthEntry> + Send + Sync>;

/// Async callback for handling provider authentication requests.
///
/// Receives a [`ProviderAuthIntent`] describing the login attempt and returns
/// either an OAuth URL to open or a completion message.
pub type ProviderAuthCallback = Arc<
    dyn Fn(
            ProviderAuthIntent,
        ) -> std::pin::Pin<
            Box<dyn std::future::Future<Output = Result<ProviderAuthResult, String>> + Send>,
        > + Send
        + Sync,
>;

/// Intent sent to the provider auth callback.
#[derive(Debug, Clone)]
pub struct ProviderAuthIntent {
    /// Target provider name (e.g. "openai", "anthropic").
    pub provider: String,
    /// API key supplied by the user (for API-key providers).
    pub api_key: Option<String>,
    /// Endpoint URL (for endpoint+key providers like Azure).
    pub endpoint: Option<String>,
    /// Authorization code from code-display OAuth flow.
    pub auth_code: Option<String>,
}

/// Result from the provider auth callback.
#[derive(Debug, Clone)]
pub enum ProviderAuthResult {
    /// OAuth URL to open in the browser.
    OAuthUrl {
        /// Full authorization URL.
        url: String,
        /// Flow type: "redirect" or "code_display".
        flow_type: String,
    },
    /// Authentication completed successfully.
    Completed {
        /// Human-readable success message.
        message: String,
    },
}

/// Pending tool approval requests awaiting user decisions.
///
/// Maps `call_id` to a oneshot sender that delivers the user's decision
/// back to the agent runtime.
type PendingApprovals =
    Arc<DashMap<String, tokio::sync::oneshot::Sender<proto::ToolApprovalDecision>>>;

/// Tool approval handler for web clients.
///
/// Sends approval requests over WebSocket and waits for the user's decision.
/// Pending requests are tracked in a shared `DashMap` keyed by `call_id`.
pub struct WebApprovalHandler {
    /// Broadcast sender used to push approval requests to all connected clients.
    ws_broadcast: broadcast::Sender<WsMessage>,
    /// Pending approval requests awaiting user decisions.
    pending: PendingApprovals,
}

impl WebApprovalHandler {
    /// Creates a new web approval handler.
    pub fn new(ws_broadcast: broadcast::Sender<WsMessage>, pending: PendingApprovals) -> Self {
        Self {
            ws_broadcast,
            pending,
        }
    }
}

/// Drop guard that removes a pending approval entry when the future is cancelled.
struct PendingApprovalGuard {
    pending: PendingApprovals,
    call_id: String,
    defused: bool,
}

impl PendingApprovalGuard {
    fn new(pending: PendingApprovals, call_id: String) -> Self {
        Self {
            pending,
            call_id,
            defused: false,
        }
    }

    /// Prevent the guard from removing the entry on drop.
    fn defuse(&mut self) {
        self.defused = true;
    }
}

impl Drop for PendingApprovalGuard {
    fn drop(&mut self) {
        if !self.defused {
            self.pending.remove(&self.call_id);
        }
    }
}

#[async_trait]
impl proto::ToolApprovalHandler for WebApprovalHandler {
    async fn request_approval(
        &self,
        req: proto::ToolApprovalRequest,
    ) -> proto::ToolApprovalDecision {
        let (tx, rx) = tokio::sync::oneshot::channel();
        self.pending.insert(req.call_id.clone(), tx);

        // Guard ensures the DashMap entry is cleaned up if this future is
        // cancelled (e.g. by the runtime's 60-second timeout).
        let mut guard = PendingApprovalGuard::new(self.pending.clone(), req.call_id.clone());

        let ws_msg = WsMessage::ToolApprovalRequest {
            call_id: req.call_id.clone(),
            tool_name: req.tool_name,
            arguments: req.arguments,
        };

        // Broadcast to all connected clients
        let _ = self.ws_broadcast.send(ws_msg);

        // Wait for the user's decision (caller handles timeout)
        match rx.await {
            Ok(decision) => {
                // Entry will be removed by the response handler; skip guard cleanup.
                guard.defuse();
                decision
            }
            Err(_) => {
                // Sender dropped (client disconnected) — guard cleans up on drop.
                proto::ToolApprovalDecision::Reject
            }
        }
    }
}

/// Provider auth entry sent to web clients.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebProviderAuthEntry {
    /// Canonical provider name.
    pub name: String,
    /// Human-readable display name.
    pub display_name: String,
    /// Auth mode: "oauth", "api_key", "endpoint_and_key", or "none".
    pub auth_mode: String,
    /// Whether the provider has stored credentials.
    pub authenticated: bool,
    /// Whether the provider is wired into the runtime.
    pub supports_runtime: bool,
}

/// A model entry sent to web clients.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct WebModelEntry {
    /// Provider name (e.g. "openai", "anthropic").
    pub provider: String,
    /// Model identifier.
    pub model: String,
    /// Whether this model is recommended for coding tasks.
    pub recommended: bool,
}

/// A single message in the conversation history sent to a web client.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct WebHistoryMessage {
    /// Role: "user", "assistant", or "tool".
    pub role: String,
    /// Message text content.
    pub content: String,
    /// Tool name for tool-result messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tool_name: Option<String>,
    /// Tool call id for tool-result messages.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tool_call_id: Option<String>,
    /// ISO 8601 creation timestamp.
    pub created_at: String,
}

/// Provides session conversation history for the web adapter.
#[async_trait]
pub trait SessionLoader: Send + Sync {
    /// Load all messages for the given session id, ordered oldest-first.
    async fn load_session_messages(&self, session_id: &str) -> Result<Vec<AgentMessage>, String>;
}

/// Convert a list of `AgentMessage` to `WebHistoryMessage`, skipping system messages.
fn to_web_history(messages: Vec<AgentMessage>) -> Vec<WebHistoryMessage> {
    messages
        .into_iter()
        .filter(|m| m.role != Role::System)
        .map(|m| WebHistoryMessage {
            role: m.role.to_string(),
            content: m.content,
            tool_name: m.tool_name,
            tool_call_id: m.tool_call_id,
            created_at: m.created_at.to_rfc3339(),
        })
        .collect()
}

/// Session entry payload shown in the web session sidebar.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct WebSessionEntry {
    /// Session identifier.
    pub id: String,
    /// Source channel id for this session.
    pub channel_id: String,
    /// Last update time as RFC3339 string.
    pub updated_at: String,
    /// First user message preview text.
    pub preview: String,
}

// ─── Query parameters ──────────────────────────────────────

/// Query parameters for WebSocket upgrade request.
#[derive(Debug, Deserialize)]
pub struct WsConnectParams {
    /// Authentication token (passed as `?token=xxx`).
    pub token: Option<String>,
    /// Session token from `/auth` endpoint (passed as `?session_token=xxx`).
    pub session_token: Option<String>,
    /// Optional client ID for session persistence.
    pub client_id: Option<String>,
    /// Optional requested session id for history sharing.
    pub session_id: Option<String>,
}

// ─── Auth session store ────────────────────────────────────

/// A server-side auth session created by `POST /auth`.
#[derive(Debug, Clone)]
struct AuthSession {
    expires_at: DateTime<Utc>,
    client_id: String,
}

/// Session tokens are valid for 24 hours.
const SESSION_TOKEN_TTL_HOURS: i64 = 24;

/// Request body for `POST /auth`.
#[derive(Debug, Deserialize)]
struct AuthRequest {
    token: String,
    #[serde(default)]
    client_id: Option<String>,
}

/// Response body from `POST /auth`.
#[derive(Debug, Serialize)]
struct AuthResponse {
    success: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    session_token: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    client_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    expires_at: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    provider: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    model: Option<String>,
}

/// Generate a cryptographically random 64-hex-character session token.
fn generate_session_token() -> String {
    use std::fmt::Write as _;
    let mut bytes = [0u8; 32];
    rand::rngs::OsRng.fill_bytes(&mut bytes);
    let mut s = String::with_capacity(64);
    for b in &bytes {
        write!(s, "{b:02x}").unwrap();
    }
    s
}

// ─── Shared state ──────────────────────────────────────────

/// Shared state for the axum web server.
struct WebState {
    /// Expected authentication token.
    auth_token: String,
    /// Event sender to the core engine.
    event_tx: mpsc::Sender<ChannelEvent>,
    /// Server-side session store: session_token -> AuthSession.
    auth_sessions: Arc<DashMap<String, AuthSession>>,
    /// Connected clients: client_id -> per-client sender.
    clients: Arc<DashMap<String, mpsc::Sender<AgentResponse>>>,
    /// Active provider name propagated to web clients.
    selected_provider: Arc<RwLock<Option<String>>>,
    /// Active model id propagated to web clients.
    selected_model: Arc<RwLock<Option<String>>>,
    /// Shared session id for web/tui history (empty -> per-client fallback).
    shared_session_id: String,
    /// Latest TUI-aligned session list snapshot.
    sessions: Arc<RwLock<Arc<Vec<WebSessionEntry>>>>,
    /// Optional session history loader for serving conversation history.
    session_loader: Option<Arc<dyn SessionLoader>>,
    /// Expanded static directory path (empty if not configured).
    #[allow(dead_code)] // retained for future use (e.g. runtime static‑dir queries)
    static_dir: String,
    /// Cached content of `index.html` read at startup (None if not available).
    index_html: Option<String>,
    /// Optional callback invoked when a web client requests a model change.
    model_change_cb: Option<ModelChangeCallback>,
    /// Static model catalog served to web clients.
    model_list: Arc<Vec<WebModelEntry>>,
    /// Optional callback returning provider auth status for web clients.
    provider_list_cb: Option<ProviderListCallback>,
    /// Optional async callback for handling provider authentication.
    provider_auth_cb: Option<ProviderAuthCallback>,
    /// Pending tool approval requests awaiting user decisions.
    pending_approvals: PendingApprovals,
    /// Broadcast sender for tool approval requests to connected clients.
    approval_broadcast: broadcast::Sender<WsMessage>,
}
// ─── WebAdapter ────────────────────────────────────────────

/// Web channel adapter — runs an axum HTTP server with WebSocket support.
#[derive(Clone)]
pub struct WebAdapter {
    /// TCP port bound by the web server.
    port: u16,
    /// Shared secret required for WebSocket authentication.
    auth_token: String,
    /// Comma-separated CORS allowlist (`*` to allow all).
    cors_origins: String,
    /// Optional static asset directory served by the adapter.
    static_dir: String,
    /// Shared session id for web/tui history (empty -> per-client fallback).
    shared_session_id: String,
    /// Latest TUI-aligned session list snapshot.
    sessions: Arc<RwLock<Arc<Vec<WebSessionEntry>>>>,
    /// Active provider name propagated to web clients.
    selected_provider: Option<String>,
    /// Active model id propagated to web clients.
    selected_model: Option<String>,
    /// Broadcast sender for responses from the agent (used by `send_response`).
    response_tx: broadcast::Sender<AgentResponse>,
    /// Connected clients — shared with the axum handlers.
    pub clients: Arc<DashMap<String, mpsc::Sender<AgentResponse>>>,
    /// Optional session history loader for serving conversation history.
    session_loader: Option<Arc<dyn SessionLoader>>,
    /// Optional callback invoked when a web client requests a model change.
    model_change_cb: Option<ModelChangeCallback>,
    /// Static model catalog served to web clients.
    model_list: Arc<Vec<WebModelEntry>>,
    /// Optional callback returning provider auth status for web clients.
    provider_list_cb: Option<ProviderListCallback>,
    /// Optional async callback for handling provider authentication.
    provider_auth_cb: Option<ProviderAuthCallback>,
    /// Broadcast sender for tool approval requests to web clients.
    approval_broadcast: broadcast::Sender<WsMessage>,
    /// Pending tool approval requests awaiting user decisions.
    pending_approvals: PendingApprovals,
}
impl WebAdapter {
    /// Creates a new web adapter with the given parameters.
    pub fn new(
        port: u16,
        auth_token: String,
        cors_origins: String,
        static_dir: String,
        shared_session_id: String,
    ) -> Self {
        let (response_tx, _) = broadcast::channel(256);
        let (approval_broadcast, _) = broadcast::channel(64);
        Self {
            port,
            auth_token,
            cors_origins,
            static_dir,
            shared_session_id,
            sessions: Arc::new(RwLock::new(Arc::new(Vec::new()))),
            selected_provider: None,
            selected_model: None,
            response_tx,
            clients: Arc::new(DashMap::new()),
            session_loader: None,
            model_change_cb: None,
            model_list: Arc::new(Vec::new()),
            provider_list_cb: None,
            provider_auth_cb: None,
            approval_broadcast,
            pending_approvals: Arc::new(DashMap::new()),
        }
    }

    /// Attaches a session history loader used to serve conversation history to clients.
    pub fn with_session_loader(mut self, loader: Arc<dyn SessionLoader>) -> Self {
        self.session_loader = Some(loader);
        self
    }

    /// Attaches a callback invoked when a web client requests a model change.
    pub fn with_model_change_callback(mut self, cb: ModelChangeCallback) -> Self {
        self.model_change_cb = Some(cb);
        self
    }

    /// Attaches a static model catalog served to web clients.
    pub fn with_model_list(mut self, models: Vec<WebModelEntry>) -> Self {
        self.model_list = Arc::new(models);
        self
    }

    /// Attaches a callback returning provider auth status for web clients.
    pub fn with_provider_list_callback(mut self, cb: ProviderListCallback) -> Self {
        self.provider_list_cb = Some(cb);
        self
    }

    /// Attaches an async callback for handling provider authentication.
    pub fn with_provider_auth_callback(mut self, cb: ProviderAuthCallback) -> Self {
        self.provider_auth_cb = Some(cb);
        self
    }

    /// Attaches the selected provider/model metadata shown on web clients.
    pub fn with_selected_model(mut self, provider: String, model: String) -> Self {
        self.selected_provider = if provider.trim().is_empty() {
            None
        } else {
            Some(provider)
        };
        self.selected_model = if model.trim().is_empty() {
            None
        } else {
            Some(model)
        };
        self
    }

    /// Replaces the server-side web session snapshot.
    pub fn set_sessions(&self, sessions: Vec<WebSessionEntry>) {
        let arc = Arc::new(sessions);
        match self.sessions.write() {
            Ok(mut guard) => *guard = arc,
            Err(poisoned) => {
                let mut guard = poisoned.into_inner();
                *guard = arc;
            }
        }
    }

    /// Creates a stable session id for a web client.
    fn make_session_id(client_id: &str) -> SessionId {
        SessionId::from(format!("web:{client_id}"))
    }

    /// Resolves the effective session id using query > shared config > per-client fallback.
    ///
    /// When a client explicitly sends a `session_id` query parameter (e.g. during
    /// session switching), that takes precedence over the shared/TUI session.
    fn resolve_session_id(
        query_session_id: Option<&str>,
        shared_session_id: &str,
        client_id: &str,
    ) -> SessionId {
        if let Some(query) = normalize_non_empty(query_session_id) {
            return SessionId::from(query);
        }
        if let Some(shared) = normalize_non_empty(Some(shared_session_id)) {
            return SessionId::from(shared);
        }
        Self::make_session_id(client_id)
    }

    /// Returns true when this connection uses the configured shared session id.
    fn is_shared_with_tui(session_id: &SessionId, shared_session_id: &str) -> bool {
        normalize_non_empty(Some(shared_session_id))
            .is_some_and(|shared| session_id.as_str() == shared)
    }

    /// Creates a [`WebApprovalHandler`] that shares state with this adapter.
    ///
    /// The returned handler can be passed to [`AgentRuntime::new`] so that
    /// tool-call approval requests are forwarded to connected web clients.
    pub fn approval_handler(&self) -> Arc<WebApprovalHandler> {
        Arc::new(WebApprovalHandler::new(
            self.approval_broadcast.clone(),
            self.pending_approvals.clone(),
        ))
    }

    /// Builds the CORS layer from the configured origins string.
    fn build_cors(&self) -> CorsLayer {
        if self.cors_origins == "*" {
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods(Any)
                .allow_headers(Any)
        } else {
            // Parse comma-separated origins
            let origins: Vec<_> = self
                .cors_origins
                .split(',')
                .filter_map(|s| s.trim().parse().ok())
                .collect();
            CorsLayer::new()
                .allow_origin(origins)
                .allow_methods(Any)
                .allow_headers(Any)
        }
    }
}

#[async_trait]
impl ChannelAdapter for WebAdapter {
    fn channel_id(&self) -> ChannelId {
        ChannelId::new("web", "server")
    }

    async fn run(self, tx: mpsc::Sender<ChannelEvent>) -> Result<(), ChannelError> {
        info!(port = self.port, "Web adapter starting");

        // Expand tilde once; reuse for state, index.html cache, and ServeDir.
        let expanded_static_dir = expand_tilde(&self.static_dir);

        // Cache index.html at startup so session_page_handler avoids per-request disk reads.
        let cached_index_html = if !expanded_static_dir.is_empty() {
            let path = std::path::PathBuf::from(&expanded_static_dir).join("index.html");
            tokio::fs::read_to_string(&path).await.ok()
        } else {
            None
        };

        let cors = self.build_cors();
        let auth_sessions: Arc<DashMap<String, AuthSession>> = Arc::new(DashMap::new());
        let state = Arc::new(WebState {
            auth_token: self.auth_token.clone(),
            event_tx: tx,
            auth_sessions: auth_sessions.clone(),
            clients: self.clients.clone(),
            selected_provider: Arc::new(RwLock::new(self.selected_provider.clone())),
            selected_model: Arc::new(RwLock::new(self.selected_model.clone())),
            shared_session_id: self.shared_session_id.clone(),
            sessions: self.sessions.clone(),
            session_loader: self.session_loader.clone(),
            static_dir: expanded_static_dir.clone(),
            index_html: cached_index_html,
            model_change_cb: self.model_change_cb.clone(),
            model_list: self.model_list.clone(),
            provider_list_cb: self.provider_list_cb.clone(),
            provider_auth_cb: self.provider_auth_cb.clone(),
            pending_approvals: self.pending_approvals.clone(),
            approval_broadcast: self.approval_broadcast.clone(),
        });

        let app = Router::new()
            .route("/ws", get(ws_handler))
            .route("/health", get(health_handler))
            .route("/auth", get(auth_page_handler).post(auth_handler))
            .route("/s/{session_id}", get(session_page_handler))
            .with_state(state)
            .layer(cors);

        // Optionally serve static files from configured directory.
        // ServeDir returns 404 for missing paths, so no exists() check is needed.
        let app = if !expanded_static_dir.is_empty() {
            info!(path = %expanded_static_dir, "Serving static files");
            app.fallback_service(tower_http::services::ServeDir::new(expanded_static_dir))
        } else {
            app
        };

        // Spawn periodic cleanup of expired auth sessions (every 5 minutes).
        let cleanup_sessions = auth_sessions.clone();
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(std::time::Duration::from_secs(300));
            loop {
                interval.tick().await;
                let now = Utc::now();
                let before = cleanup_sessions.len();
                cleanup_sessions.retain(|_, session| session.expires_at > now);
                let removed = before - cleanup_sessions.len();
                if removed > 0 {
                    debug!(removed, "Cleaned up expired auth sessions");
                }
            }
        });

        let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", self.port))
            .await
            .map_err(|e| ChannelError::ConnectionFailed(format!("bind failed: {e}")))?;

        info!(port = self.port, "Web adapter listening");

        axum::serve(listener, app)
            .with_graceful_shutdown(async {
                let _ = tokio::signal::ctrl_c().await;
            })
            .await
            .map_err(|e| ChannelError::ConnectionFailed(format!("server error: {e}")))?;

        info!("Web adapter stopped");
        Ok(())
    }

    async fn send_response(&self, resp: AgentResponse) -> Result<(), ChannelError> {
        // Route response to the correct per-client sender
        let client_id = resp
            .channel_id
            .as_str()
            .strip_prefix("web:")
            .unwrap_or("")
            .to_string();
        let channel_id = resp.channel_id.clone();
        let session_id = resp.session_id.clone();

        if let Some(sender) = self.clients.get(&client_id).map(|r| r.clone()) {
            if let Err(e) = sender.send(resp).await {
                error!(
                    client_id = %client_id,
                    channel_id = %channel_id,
                    session_id = %session_id,
                    "Failed to route response to web client queue: {e}"
                );
                return Err(ChannelError::SendFailed(format!("client send failed: {e}")));
            }
        } else {
            // Broadcast fallback
            warn!(
                client_id = %client_id,
                channel_id = %channel_id,
                session_id = %session_id,
                "Web client queue missing; using broadcast fallback"
            );
            let _ = self.response_tx.send(resp);
        }
        Ok(())
    }
}

// ─── Axum handlers ─────────────────────────────────────────

/// Health check endpoint.
async fn health_handler() -> &'static str {
    "ok"
}

/// `GET /auth` — redirect to index page (auth modal).
async fn auth_page_handler() -> impl IntoResponse {
    Redirect::temporary("/")
}

/// `GET /s/{session_id}` — serve `index.html` for direct session access.
///
/// The client-side JS reads the path to determine which session to connect to.
/// Uses the content cached at startup to avoid per-request disk reads.
async fn session_page_handler(
    Path(_session_id): Path<String>,
    State(state): State<Arc<WebState>>,
) -> impl IntoResponse {
    match &state.index_html {
        Some(html) => axum::response::Html(html.clone()).into_response(),
        None => (
            StatusCode::NOT_FOUND,
            "index.html not configured or not found",
        )
            .into_response(),
    }
}

/// `POST /auth` — validate token and issue a server-side session token.
async fn auth_handler(
    State(state): State<Arc<WebState>>,
    Json(body): Json<AuthRequest>,
) -> impl IntoResponse {
    let token_valid = validate_token(&body.token, &state.auth_token);

    if !token_valid && !state.auth_token.is_empty() {
        return Json(AuthResponse {
            success: false,
            session_token: None,
            client_id: None,
            expires_at: None,
            error: Some("Invalid token".to_string()),
            provider: None,
            model: None,
        });
    }

    let client_id = body
        .client_id
        .filter(|id| !id.is_empty())
        .unwrap_or_else(|| Uuid::new_v4().to_string());

    let session_token = generate_session_token();
    let expires_at = Utc::now() + ChronoDuration::hours(SESSION_TOKEN_TTL_HOURS);

    state.auth_sessions.insert(
        session_token.clone(),
        AuthSession {
            expires_at,
            client_id: client_id.clone(),
        },
    );

    info!(client_id = %client_id, "Auth session created via POST /auth");

    Json(AuthResponse {
        success: true,
        session_token: Some(session_token),
        client_id: Some(client_id),
        expires_at: Some(expires_at.to_rfc3339()),
        error: None,
        provider: state.selected_provider.read().unwrap().clone(),
        model: state.selected_model.read().unwrap().clone(),
    })
}

/// WebSocket upgrade handler.
async fn ws_handler(
    ws: WebSocketUpgrade,
    Query(params): Query<WsConnectParams>,
    State(state): State<Arc<WebState>>,
) -> impl IntoResponse {
    // Try session_token first (from POST /auth flow)
    let session_auth = params.session_token.as_deref().and_then(|st| {
        let session = state.auth_sessions.get(st)?;
        if session.expires_at <= Utc::now() {
            state.auth_sessions.remove(st);
            return None;
        }
        Some(session.client_id.clone())
    });

    if let Some(session_client_id) = session_auth {
        // Authenticated via session_token
        let client_id = params
            .client_id
            .filter(|id| !id.is_empty())
            .unwrap_or(session_client_id);
        let session_id = WebAdapter::resolve_session_id(
            params.session_id.as_deref(),
            &state.shared_session_id,
            &client_id,
        );
        let shared_with_tui = WebAdapter::is_shared_with_tui(&session_id, &state.shared_session_id);

        return ws
            .on_upgrade(move |socket| {
                handle_ws(socket, client_id, session_id, shared_with_tui, state)
            })
            .into_response();
    }

    // Fallback: raw token query parameter (handles stale session_token + valid raw token,
    // new tabs with saved token, and legacy ?token= connections)
    let token_valid = params
        .token
        .as_deref()
        .is_some_and(|t| validate_token(t, &state.auth_token));

    if !token_valid && !state.auth_token.is_empty() {
        return StatusCode::UNAUTHORIZED.into_response();
    }

    let client_id = params
        .client_id
        .filter(|id| !id.is_empty())
        .unwrap_or_else(|| Uuid::new_v4().to_string());

    // Auto-create a server-side session so subsequent reconnects can use session_token
    if token_valid && !state.auth_token.is_empty() {
        let new_session_token = generate_session_token();
        let expires_at = Utc::now() + ChronoDuration::hours(SESSION_TOKEN_TTL_HOURS);
        state.auth_sessions.insert(
            new_session_token,
            AuthSession {
                expires_at,
                client_id: client_id.clone(),
            },
        );
    }

    let session_id = WebAdapter::resolve_session_id(
        params.session_id.as_deref(),
        &state.shared_session_id,
        &client_id,
    );
    let shared_with_tui = WebAdapter::is_shared_with_tui(&session_id, &state.shared_session_id);

    ws.on_upgrade(move |socket| handle_ws(socket, client_id, session_id, shared_with_tui, state))
        .into_response()
}

/// Manages a single WebSocket connection lifecycle.
async fn handle_ws(
    socket: ws::WebSocket,
    client_id: String,
    session_id: SessionId,
    shared_with_tui: bool,
    state: Arc<WebState>,
) {
    let (mut ws_tx, mut ws_rx) = socket.split();

    // Per-client response channel
    let (resp_tx, mut resp_rx) = mpsc::channel::<AgentResponse>(64);
    state.clients.insert(client_id.clone(), resp_tx);
    let channel_id = ChannelId::new("web", &client_id);

    info!(
        client_id = %client_id,
        channel_id = %channel_id,
        session_id = %session_id,
        shared_with_tui,
        "WebSocket client connected"
    );

    // Send auth_result to client
    let auth_msg = WsMessage::AuthResult {
        success: true,
        client_id: Some(client_id.clone()),
        error: None,
        provider: state.selected_provider.read().unwrap().clone(),
        model: state.selected_model.read().unwrap().clone(),
        session_id: Some(session_id.as_str().to_string()),
        shared_with_tui: Some(shared_with_tui),
    };
    if let Err(e) = send_ws_message(&mut ws_tx, &auth_msg).await {
        error!(
            client_id = %client_id,
            channel_id = %channel_id,
            session_id = %session_id,
            "Failed to send auth_result: {e}"
        );
        drop(resp_rx);
        state.clients.remove_if(&client_id, |_, tx| tx.is_closed());
        return;
    }

    let initial_sessions = sessions_snapshot(&state.sessions);
    debug!(
        client_id = %client_id,
        channel_id = %channel_id,
        session_id = %session_id,
        session_count = initial_sessions.len(),
        "Sending initial sessions_list"
    );
    if let Err(e) = send_ws_message(
        &mut ws_tx,
        &WsMessage::SessionsList {
            sessions: initial_sessions,
        },
    )
    .await
    {
        error!(
            client_id = %client_id,
            channel_id = %channel_id,
            session_id = %session_id,
            "Failed to send sessions_list: {e}"
        );
        drop(resp_rx);
        state.clients.remove_if(&client_id, |_, tx| tx.is_closed());
        return;
    }

    // Send session history if a loader is configured
    if let Some(loader) = &state.session_loader {
        match loader.load_session_messages(session_id.as_str()).await {
            Ok(msgs) => {
                let history_msg = WsMessage::SessionHistory {
                    session_id: session_id.as_str().to_string(),
                    messages: to_web_history(msgs),
                };
                if let Err(e) = send_ws_message(&mut ws_tx, &history_msg).await {
                    error!(
                        client_id = %client_id,
                        channel_id = %channel_id,
                        session_id = %session_id,
                        "Failed to send session_history: {e}"
                    );
                    drop(resp_rx);
                    state.clients.remove_if(&client_id, |_, tx| tx.is_closed());
                    return;
                }
                debug!(
                    client_id = %client_id,
                    session_id = %session_id,
                    "Sent session_history on connect"
                );
            }
            Err(e) => {
                warn!(
                    client_id = %client_id,
                    session_id = %session_id,
                    "Failed to load session history: {e}"
                );
            }
        }
    }

    let (ws_out_tx, mut ws_out_rx) = mpsc::channel::<WsMessage>(64);

    let client_id_read = client_id.clone();
    let channel_id_read = channel_id.clone();
    let session_id_read = session_id.clone();
    let state_read = state.clone();
    let ws_out_tx_read = ws_out_tx.clone();

    // Read task: client -> server
    let mut read_task = tokio::spawn(async move {
        while let Some(Ok(msg)) = ws_rx.next().await {
            let ws::Message::Text(text) = msg else {
                continue;
            };
            let Ok(ws_msg) = serde_json::from_str::<WsMessage>(&text) else {
                warn!(
                    client_id = %client_id_read,
                    channel_id = %channel_id_read,
                    session_id = %session_id_read,
                    "Invalid WS message"
                );
                continue;
            };
            match ws_msg {
                WsMessage::UserMessage {
                    content,
                    message_id,
                } => {
                    let event = ChannelEvent::new(
                        channel_id_read.clone(),
                        session_id_read.clone(),
                        content,
                    );
                    match state_read.event_tx.send(event).await {
                        Ok(_) => {
                            let ack = WsMessage::MessageAck {
                                message_id,
                                session_id: session_id_read.as_str().to_string(),
                            };
                            if let Err(e) = ws_out_tx_read.send(ack).await {
                                error!(
                                    client_id = %client_id_read,
                                    channel_id = %channel_id_read,
                                    session_id = %session_id_read,
                                    "Failed to queue message_ack: {e}"
                                );
                                break;
                            }
                        }
                        Err(e) => {
                            error!(
                                client_id = %client_id_read,
                                channel_id = %channel_id_read,
                                session_id = %session_id_read,
                                "Failed to enqueue web event: {e}"
                            );
                            let _ = ws_out_tx_read
                                .send(WsMessage::MessageError {
                                    message_id,
                                    session_id: Some(session_id_read.as_str().to_string()),
                                    error: "Failed to queue request. Check server connection."
                                        .to_string(),
                                })
                                .await;
                            break;
                        }
                    }
                }
                WsMessage::Ping => {
                    debug!(
                        client_id = %client_id_read,
                        channel_id = %channel_id_read,
                        session_id = %session_id_read,
                        "Ping received"
                    );
                    if let Err(e) = ws_out_tx_read.send(WsMessage::Pong).await {
                        error!(
                            client_id = %client_id_read,
                            channel_id = %channel_id_read,
                            session_id = %session_id_read,
                            "Failed to queue pong: {e}"
                        );
                        break;
                    }
                }
                WsMessage::SessionsRequest => {
                    debug!(
                        client_id = %client_id_read,
                        channel_id = %channel_id_read,
                        session_id = %session_id_read,
                        "Received sessions_request"
                    );
                    let sessions = sessions_snapshot(&state_read.sessions);
                    debug!(
                        client_id = %client_id_read,
                        channel_id = %channel_id_read,
                        session_id = %session_id_read,
                        session_count = sessions.len(),
                        "Queueing sessions_list"
                    );
                    if let Err(e) = ws_out_tx_read
                        .send(WsMessage::SessionsList { sessions })
                        .await
                    {
                        error!(
                            client_id = %client_id_read,
                            channel_id = %channel_id_read,
                            session_id = %session_id_read,
                            "Failed to queue sessions_list: {e}"
                        );
                        break;
                    }
                }
                WsMessage::SessionHistoryRequest {
                    session_id: req_session_id,
                } => {
                    debug!(
                        client_id = %client_id_read,
                        channel_id = %channel_id_read,
                        session_id = %session_id_read,
                        requested_session = %req_session_id,
                        "Received session_history_request"
                    );
                    if let Some(loader) = &state_read.session_loader {
                        let history_msg = match loader.load_session_messages(&req_session_id).await
                        {
                            Ok(msgs) => WsMessage::SessionHistory {
                                session_id: req_session_id.clone(),
                                messages: to_web_history(msgs),
                            },
                            Err(e) => {
                                warn!(
                                    client_id = %client_id_read,
                                    requested_session = %req_session_id,
                                    "Failed to load session history on request: {e}"
                                );
                                WsMessage::SessionHistory {
                                    session_id: req_session_id.clone(),
                                    messages: Vec::new(),
                                }
                            }
                        };
                        if let Err(e) = ws_out_tx_read.send(history_msg).await {
                            error!(
                                client_id = %client_id_read,
                                channel_id = %channel_id_read,
                                session_id = %session_id_read,
                                "Failed to queue session_history: {e}"
                            );
                            break;
                        }
                    }
                }
                WsMessage::ModelListRequest => {
                    let all_models = state_read.model_list.as_ref().clone();
                    let models = if let Some(cb) = &state_read.provider_list_cb {
                        let providers = cb();
                        let authenticated: std::collections::HashSet<String> = providers
                            .iter()
                            .filter(|p| p.authenticated || p.auth_mode == "none")
                            .map(|p| p.name.clone())
                            .collect();
                        if authenticated.is_empty() {
                            all_models
                        } else {
                            all_models
                                .into_iter()
                                .filter(|m| authenticated.contains(&m.provider))
                                .collect()
                        }
                    } else {
                        all_models
                    };
                    if let Err(e) = ws_out_tx_read.send(WsMessage::ModelList { models }).await {
                        error!(
                            client_id = %client_id_read,
                            channel_id = %channel_id_read,
                            session_id = %session_id_read,
                            "Failed to send model_list: {e}"
                        );
                        break;
                    }
                }
                WsMessage::ModelChange { provider, model } => {
                    info!(
                        client_id = %client_id_read,
                        provider = %provider,
                        model = %model,
                        "Model change requested"
                    );
                    if let Some(cb) = &state_read.model_change_cb {
                        cb(provider.clone(), model.clone());
                    }
                    // Update shared state so new connections see the change
                    *state_read.selected_provider.write().unwrap() = Some(provider.clone());
                    *state_read.selected_model.write().unwrap() = Some(model.clone());
                    if let Err(e) = ws_out_tx_read
                        .send(WsMessage::ModelChanged {
                            provider: provider.clone(),
                            model: model.clone(),
                        })
                        .await
                    {
                        error!(
                            client_id = %client_id_read,
                            channel_id = %channel_id_read,
                            session_id = %session_id_read,
                            "Failed to send model_changed: {e}"
                        );
                        break;
                    }
                }
                WsMessage::ProviderAuthRequest => {
                    if let Some(cb) = &state_read.provider_list_cb {
                        let providers = cb();
                        if let Err(e) = ws_out_tx_read
                            .send(WsMessage::ProviderAuthStatus { providers })
                            .await
                        {
                            error!(
                                client_id = %client_id_read,
                                channel_id = %channel_id_read,
                                session_id = %session_id_read,
                                "Failed to send provider_auth_status: {e}"
                            );
                            break;
                        }
                    }
                }
                WsMessage::ProviderLogin {
                    provider,
                    api_key,
                    endpoint,
                    auth_code,
                } => {
                    info!(
                        client_id = %client_id_read,
                        provider = %provider,
                        "Provider login requested"
                    );
                    if let Some(cb) = &state_read.provider_auth_cb {
                        let intent = ProviderAuthIntent {
                            provider: provider.clone(),
                            api_key,
                            endpoint,
                            auth_code,
                        };
                        let cb = cb.clone();
                        let ws_tx = ws_out_tx_read.clone();
                        tokio::spawn(async move {
                            let result = cb(intent).await;
                            let msg = match result {
                                Ok(ProviderAuthResult::OAuthUrl { url, flow_type }) => {
                                    WsMessage::ProviderAuthUrl {
                                        provider,
                                        auth_url: url,
                                        flow_type,
                                    }
                                }
                                Ok(ProviderAuthResult::Completed { message }) => {
                                    WsMessage::ProviderAuthCompleted {
                                        provider,
                                        success: true,
                                        message,
                                    }
                                }
                                Err(e) => WsMessage::ProviderAuthCompleted {
                                    provider,
                                    success: false,
                                    message: e,
                                },
                            };
                            let _ = ws_tx.send(msg).await;
                        });
                    }
                }
                WsMessage::CancelGeneration => {
                    info!(
                        client_id = %client_id_read,
                        channel_id = %channel_id_read,
                        session_id = %session_id_read,
                        "Cancel generation requested"
                    );
                    // Drop the response sender for this client to signal cancellation.
                    // The spawned processing task will get a send error and stop.
                    // Re-insert a fresh channel so the next message works.
                    let (new_tx, new_rx) = mpsc::channel::<AgentResponse>(64);
                    state_read.clients.insert(client_id_read.clone(), new_tx);
                    drop(new_rx);
                    // Send confirmation back to the client.
                    if let Err(e) = ws_out_tx_read.send(WsMessage::GenerationCancelled).await {
                        error!(
                            client_id = %client_id_read,
                            "Failed to send generation_cancelled: {e}"
                        );
                        break;
                    }
                }
                WsMessage::ToolApprovalResponse { call_id, decision } => {
                    debug!(
                        client_id = %client_id_read,
                        call_id = %call_id,
                        decision = %decision,
                        "Tool approval response received"
                    );
                    let parsed = match decision.as_str() {
                        "approve" => proto::ToolApprovalDecision::Approve,
                        "allow_for_session" => proto::ToolApprovalDecision::AllowForSession,
                        _ => proto::ToolApprovalDecision::Reject,
                    };
                    if let Some((_, tx)) = state_read.pending_approvals.remove(&call_id) {
                        let _ = tx.send(parsed);
                    } else {
                        warn!(
                            call_id = %call_id,
                            "No pending approval request found for call_id"
                        );
                    }
                }
                _ => {
                    debug!(
                        client_id = %client_id_read,
                        channel_id = %channel_id_read,
                        session_id = %session_id_read,
                        "Ignoring WS message"
                    );
                }
            }
        }
    });

    drop(ws_out_tx);

    let mut approval_rx = state.approval_broadcast.subscribe();

    let client_id_write = client_id.clone();
    let channel_id_write = channel_id.clone();
    let session_id_write = session_id.clone();

    // Write task: server -> client
    let mut write_task = tokio::spawn(async move {
        let mut resp_open = true;
        let mut ws_out_open = true;

        loop {
            if !resp_open && !ws_out_open {
                break;
            }
            tokio::select! {
                maybe_resp = resp_rx.recv(), if resp_open => {
                    match maybe_resp {
                        Some(resp) => {
                            let ws_msg = WsMessage::AgentReply {
                                content: resp.content,
                                is_error: resp.is_error,
                            };
                            if let Err(e) = send_ws_message(&mut ws_tx, &ws_msg).await {
                                error!(
                                    client_id = %client_id_write,
                                    channel_id = %channel_id_write,
                                    session_id = %session_id_write,
                                    "Failed to send response over websocket: {e}"
                                );
                                break;
                            }
                        }
                        None => resp_open = false,
                    }
                }
                maybe_ws = ws_out_rx.recv(), if ws_out_open => {
                    match maybe_ws {
                        Some(ws_msg) => {
                            if let Err(e) = send_ws_message(&mut ws_tx, &ws_msg).await {
                                error!(
                                    client_id = %client_id_write,
                                    channel_id = %channel_id_write,
                                    session_id = %session_id_write,
                                    "Failed to send websocket diagnostic event: {e}"
                                );
                                break;
                            }
                        }
                        None => ws_out_open = false,
                    }
                }
                result = approval_rx.recv() => {
                    match result {
                        Ok(ws_msg) => {
                            if let Err(e) = send_ws_message(&mut ws_tx, &ws_msg).await {
                                error!(
                                    client_id = %client_id_write,
                                    channel_id = %channel_id_write,
                                    session_id = %session_id_write,
                                    "Failed to send tool approval request: {e}"
                                );
                                break;
                            }
                        }
                        Err(broadcast::error::RecvError::Lagged(n)) => {
                            warn!(
                                client_id = %client_id_write,
                                lagged = n,
                                "Approval broadcast lagged"
                            );
                        }
                        Err(broadcast::error::RecvError::Closed) => {}
                    }
                }
            }
        }
    });

    // Wait for either task to finish
    tokio::select! {
        _ = &mut read_task => {
            write_task.abort();
            let _ = write_task.await;
        },
        _ = &mut write_task => {
            read_task.abort();
            let _ = read_task.await;
        },
    }

    // Only remove if the stored sender is closed (our receiver was dropped).
    // A newer connection from the same client_id may have already replaced
    // this entry; removing unconditionally would break that connection.
    state.clients.remove_if(&client_id, |_, tx| tx.is_closed());
    info!(
        client_id = %client_id,
        channel_id = %channel_id,
        session_id = %session_id,
        "WebSocket client disconnected"
    );
}

// ─── Helpers ───────────────────────────────────────────────

async fn send_ws_message(
    ws_tx: &mut futures_util::stream::SplitSink<ws::WebSocket, ws::Message>,
    ws_msg: &WsMessage,
) -> Result<(), String> {
    let json = serde_json::to_string(ws_msg).map_err(|e| e.to_string())?;
    ws_tx
        .send(ws::Message::Text(json.into()))
        .await
        .map_err(|e| e.to_string())
}

fn normalize_non_empty(value: Option<&str>) -> Option<&str> {
    value.map(str::trim).filter(|v| !v.is_empty())
}

/// Returns a snapshot of the session list.
///
/// The read lock is held only long enough to clone the inner `Arc` (a pointer
/// bump), so the actual `Vec` clone — if any — happens outside the lock.
fn sessions_snapshot(sessions: &Arc<RwLock<Arc<Vec<WebSessionEntry>>>>) -> Vec<WebSessionEntry> {
    let arc = match sessions.read() {
        Ok(guard) => Arc::clone(&*guard),
        Err(poisoned) => Arc::clone(&*poisoned.into_inner()),
    };
    (*arc).clone()
}

/// Token comparison for authentication.
fn validate_token(given: &str, expected: &str) -> bool {
    if expected.is_empty() {
        return true; // no auth required
    }
    given == expected
}

/// Expands `~` at the start of a path to `$HOME`.
fn expand_tilde(path: &str) -> String {
    if let Some(rest) = path.strip_prefix('~') {
        let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
        format!("{home}{rest}")
    } else {
        path.to_string()
    }
}

// ─── Tests ─────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::{Duration, timeout};

    #[test]
    fn ws_message_user_message_serializes_correctly() {
        let msg = WsMessage::UserMessage {
            content: "hello".to_string(),
            message_id: None,
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains("\"type\":\"message\""));
        assert!(json.contains("\"content\":\"hello\""));
    }

    #[test]
    fn ws_message_agent_reply_serializes_correctly() {
        let msg = WsMessage::AgentReply {
            content: "world".to_string(),
            is_error: false,
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains("\"type\":\"response\""));
        assert!(json.contains("\"is_error\":false"));
    }

    #[test]
    fn ws_message_ping_pong_roundtrip() {
        let ping = serde_json::to_string(&WsMessage::Ping).expect("serialize ping");
        let parsed: WsMessage = serde_json::from_str(&ping).expect("deserialize ping");
        assert!(matches!(parsed, WsMessage::Ping));

        let pong = serde_json::to_string(&WsMessage::Pong).expect("serialize pong");
        let parsed: WsMessage = serde_json::from_str(&pong).expect("deserialize pong");
        assert!(matches!(parsed, WsMessage::Pong));
    }

    #[test]
    fn ws_message_auth_result_roundtrip() {
        let msg = WsMessage::AuthResult {
            success: true,
            client_id: Some("abc".to_string()),
            error: None,
            provider: Some("anthropic".to_string()),
            model: Some("claude-sonnet-4-6".to_string()),
            session_id: Some("shared-main".to_string()),
            shared_with_tui: Some(true),
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::AuthResult {
                success,
                provider,
                model,
                session_id,
                shared_with_tui,
                ..
            } => {
                assert!(success);
                assert_eq!(provider.as_deref(), Some("anthropic"));
                assert_eq!(model.as_deref(), Some("claude-sonnet-4-6"));
                assert_eq!(session_id.as_deref(), Some("shared-main"));
                assert_eq!(shared_with_tui, Some(true));
            }
            _ => panic!("expected AuthResult"),
        }
    }

    #[test]
    fn ws_message_sessions_request_roundtrip() {
        let json = serde_json::to_string(&WsMessage::SessionsRequest).expect("serialize");
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        assert!(matches!(parsed, WsMessage::SessionsRequest));
    }

    #[test]
    fn ws_message_sessions_list_roundtrip() {
        let msg = WsMessage::SessionsList {
            sessions: vec![WebSessionEntry {
                id: "session-a".to_string(),
                channel_id: "cli:tui".to_string(),
                updated_at: "2026-02-25T00:00:00Z".to_string(),
                preview: "hello".to_string(),
            }],
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::SessionsList { sessions } => {
                assert_eq!(sessions.len(), 1);
                assert_eq!(sessions[0].id, "session-a");
                assert_eq!(sessions[0].channel_id, "cli:tui");
            }
            _ => panic!("expected SessionsList"),
        }
    }

    #[test]
    fn ws_message_ack_roundtrip() {
        let msg = WsMessage::MessageAck {
            message_id: Some("m1".to_string()),
            session_id: "shared-main".to_string(),
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::MessageAck {
                message_id,
                session_id,
            } => {
                assert_eq!(message_id.as_deref(), Some("m1"));
                assert_eq!(session_id, "shared-main");
            }
            _ => panic!("expected MessageAck"),
        }
    }

    #[test]
    fn validate_token_allows_empty_expected() {
        assert!(validate_token("anything", ""));
        assert!(validate_token("", ""));
    }

    #[test]
    fn validate_token_checks_exact_match() {
        assert!(validate_token("secret", "secret"));
        assert!(!validate_token("wrong", "secret"));
        assert!(!validate_token("", "secret"));
    }

    #[test]
    fn expand_tilde_replaces_home() {
        let expanded = expand_tilde("~/.openpista/web");
        assert!(!expanded.starts_with('~'));
        assert!(expanded.ends_with("/.openpista/web"));
    }

    #[test]
    fn expand_tilde_leaves_absolute_paths_unchanged() {
        assert_eq!(expand_tilde("/var/www"), "/var/www");
    }

    #[test]
    fn make_session_id_uses_web_prefix() {
        let sid = WebAdapter::make_session_id("abc123");
        assert_eq!(sid.as_str(), "web:abc123");
    }

    #[test]
    fn resolve_session_id_prefers_query_over_shared_session() {
        let sid = WebAdapter::resolve_session_id(Some("query-session"), "shared-main", "client-a");
        assert_eq!(sid.as_str(), "query-session");
    }

    #[test]
    fn resolve_session_id_uses_shared_session_when_query_missing() {
        let sid = WebAdapter::resolve_session_id(None, "shared-main", "client-a");
        assert_eq!(sid.as_str(), "shared-main");
    }

    #[test]
    fn resolve_session_id_uses_query_when_shared_empty() {
        let sid = WebAdapter::resolve_session_id(Some("query-session"), "   ", "client-a");
        assert_eq!(sid.as_str(), "query-session");
    }

    #[test]
    fn resolve_session_id_falls_back_to_client_prefix_when_shared_and_query_empty() {
        let sid = WebAdapter::resolve_session_id(None, "   ", "client-a");
        assert_eq!(sid.as_str(), "web:client-a");
    }

    #[test]
    fn channel_id_uses_web_prefix() {
        let channel = ChannelId::new("web", "test-client");
        assert_eq!(channel.as_str(), "web:test-client");
    }

    #[test]
    fn web_adapter_creates_with_defaults() {
        let adapter = WebAdapter::new(
            3210,
            "token123".to_string(),
            "*".to_string(),
            "~/.openpista/web".to_string(),
            "shared-main".to_string(),
        );
        assert_eq!(adapter.port, 3210);
        assert_eq!(adapter.auth_token, "token123");
        assert_eq!(adapter.shared_session_id, "shared-main");
        assert!(adapter.selected_provider.is_none());
        assert!(adapter.selected_model.is_none());
        assert!(adapter.clients.is_empty());
        assert!(adapter.sessions.read().expect("sessions lock").is_empty());
    }

    #[test]
    fn with_selected_model_sets_metadata() {
        let adapter = WebAdapter::new(
            3210,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        )
        .with_selected_model("openai".to_string(), "gpt-4o".to_string());
        assert_eq!(adapter.selected_provider.as_deref(), Some("openai"));
        assert_eq!(adapter.selected_model.as_deref(), Some("gpt-4o"));
    }

    #[test]
    fn set_sessions_replaces_snapshot() {
        let adapter = WebAdapter::new(
            3210,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        );
        adapter.set_sessions(vec![WebSessionEntry {
            id: "session-a".to_string(),
            channel_id: "cli:tui".to_string(),
            updated_at: "2026-02-25T00:00:00Z".to_string(),
            preview: "first".to_string(),
        }]);
        adapter.set_sessions(vec![WebSessionEntry {
            id: "session-b".to_string(),
            channel_id: "web:client-1".to_string(),
            updated_at: "2026-02-26T00:00:00Z".to_string(),
            preview: "second".to_string(),
        }]);

        let snapshot = adapter.sessions.read().expect("sessions lock");
        assert_eq!(snapshot.len(), 1);
        assert_eq!(snapshot[0].id, "session-b");
        assert_eq!(snapshot[0].preview, "second");
    }

    #[tokio::test]
    async fn send_response_routes_to_registered_client_queue() {
        let adapter = WebAdapter::new(
            3211,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        );
        let (tx, mut rx) = mpsc::channel::<AgentResponse>(2);
        adapter.clients.insert("client-a".to_string(), tx);

        let resp = AgentResponse::new(
            ChannelId::new("web", "client-a"),
            SessionId::from("web:client-a".to_string()),
            "hello web",
        );
        adapter
            .send_response(resp.clone())
            .await
            .expect("send response");

        let delivered = timeout(Duration::from_millis(250), rx.recv())
            .await
            .expect("timeout waiting for client queue")
            .expect("missing client response");
        assert_eq!(delivered.content, "hello web");
        assert!(!delivered.is_error);
    }

    #[tokio::test]
    async fn send_response_returns_error_when_client_queue_is_closed() {
        let adapter = WebAdapter::new(
            3212,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        );
        let (tx, rx) = mpsc::channel::<AgentResponse>(1);
        drop(rx);
        adapter.clients.insert("closed-client".to_string(), tx);

        let resp = AgentResponse::new(
            ChannelId::new("web", "closed-client"),
            SessionId::from("web:closed-client".to_string()),
            "should fail",
        );
        let err = adapter
            .send_response(resp)
            .await
            .expect_err("expected send error");
        assert!(matches!(err, ChannelError::SendFailed(_)));
    }

    #[tokio::test]
    async fn send_response_falls_back_to_broadcast_for_unknown_client() {
        let adapter = WebAdapter::new(
            3213,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        );
        let mut broadcast_rx = adapter.response_tx.subscribe();
        let resp = AgentResponse::new(
            ChannelId::new("web", "missing-client"),
            SessionId::from("web:missing-client".to_string()),
            "fallback broadcast",
        );

        adapter
            .send_response(resp.clone())
            .await
            .expect("send response");
        let delivered = timeout(Duration::from_millis(250), broadcast_rx.recv())
            .await
            .expect("timeout waiting for broadcast")
            .expect("broadcast channel closed");
        assert_eq!(delivered.content, "fallback broadcast");
    }

    #[test]
    fn web_history_message_serializes_correctly() {
        let msg = WebHistoryMessage {
            role: "user".to_string(),
            content: "hello".to_string(),
            tool_name: None,
            tool_call_id: None,
            created_at: "2026-02-27T00:00:00Z".to_string(),
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains(r#""role":"user""#));
        assert!(json.contains(r#""content":"hello""#));
        // None fields should be skipped
        assert!(!json.contains("tool_name"));
        assert!(!json.contains("tool_call_id"));
    }

    #[test]
    fn ws_message_session_history_roundtrip() {
        let msg = WsMessage::SessionHistory {
            session_id: "session-a".to_string(),
            messages: vec![
                WebHistoryMessage {
                    role: "user".to_string(),
                    content: "hi".to_string(),
                    tool_name: None,
                    tool_call_id: None,
                    created_at: "2026-02-27T00:00:00Z".to_string(),
                },
                WebHistoryMessage {
                    role: "assistant".to_string(),
                    content: "hello".to_string(),
                    tool_name: None,
                    tool_call_id: None,
                    created_at: "2026-02-27T00:00:01Z".to_string(),
                },
            ],
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains(r#""type":"session_history""#));
        assert!(json.contains(r#""session_id":"session-a""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::SessionHistory {
                session_id,
                messages,
            } => {
                assert_eq!(session_id, "session-a");
                assert_eq!(messages.len(), 2);
                assert_eq!(messages[0].role, "user");
                assert_eq!(messages[1].role, "assistant");
            }
            _ => panic!("expected SessionHistory"),
        }
    }

    #[test]
    fn ws_message_session_history_request_roundtrip() {
        let msg = WsMessage::SessionHistoryRequest {
            session_id: "session-b".to_string(),
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains(r#""type":"session_history_request""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::SessionHistoryRequest { session_id } => {
                assert_eq!(session_id, "session-b");
            }
            _ => panic!("expected SessionHistoryRequest"),
        }
    }

    #[test]
    fn to_web_history_filters_system_messages_and_preserves_order() {
        use proto::{AgentMessage, Role};
        let session_id = proto::SessionId::from("s1");
        let messages = vec![
            AgentMessage::new(session_id.clone(), Role::User, "hello"),
            AgentMessage::new(session_id.clone(), Role::System, "system prompt"),
            AgentMessage::new(session_id.clone(), Role::Assistant, "hi there"),
        ];
        let history = to_web_history(messages);
        assert_eq!(history.len(), 2);
        assert_eq!(history[0].role, "user");
        assert_eq!(history[0].content, "hello");
        assert_eq!(history[1].role, "assistant");
        assert_eq!(history[1].content, "hi there");
    }

    #[test]
    fn with_session_loader_sets_loader() {
        struct DummyLoader;
        #[async_trait]
        impl SessionLoader for DummyLoader {
            async fn load_session_messages(
                &self,
                _session_id: &str,
            ) -> Result<Vec<proto::AgentMessage>, String> {
                Ok(vec![])
            }
        }

        let adapter = WebAdapter::new(
            3210,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        )
        .with_session_loader(Arc::new(DummyLoader));

        assert!(adapter.session_loader.is_some());
    }

    #[test]
    fn ws_message_model_list_request_roundtrip() {
        let json = serde_json::to_string(&WsMessage::ModelListRequest).expect("serialize");
        assert!(json.contains(r#""type":"model_list_request""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        assert!(matches!(parsed, WsMessage::ModelListRequest));
    }

    #[test]
    fn ws_message_model_list_roundtrip() {
        let msg = WsMessage::ModelList {
            models: vec![WebModelEntry {
                provider: "openai".to_string(),
                model: "gpt-4o".to_string(),
                recommended: true,
            }],
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains(r#""type":"model_list""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::ModelList { models } => {
                assert_eq!(models.len(), 1);
                assert_eq!(models[0].provider, "openai");
                assert_eq!(models[0].model, "gpt-4o");
                assert!(models[0].recommended);
            }
            _ => panic!("expected ModelList"),
        }
    }

    #[test]
    fn ws_message_model_change_roundtrip() {
        let msg = WsMessage::ModelChange {
            provider: "anthropic".to_string(),
            model: "claude-sonnet-4-6".to_string(),
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains(r#""type":"model_change""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::ModelChange { provider, model } => {
                assert_eq!(provider, "anthropic");
                assert_eq!(model, "claude-sonnet-4-6");
            }
            _ => panic!("expected ModelChange"),
        }
    }

    #[test]
    fn ws_message_model_changed_roundtrip() {
        let msg = WsMessage::ModelChanged {
            provider: "openai".to_string(),
            model: "gpt-4o".to_string(),
        };
        let json = serde_json::to_string(&msg).expect("serialize");
        assert!(json.contains(r#""type":"model_changed""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        match parsed {
            WsMessage::ModelChanged { provider, model } => {
                assert_eq!(provider, "openai");
                assert_eq!(model, "gpt-4o");
            }
            _ => panic!("expected ModelChanged"),
        }
    }

    #[test]
    fn web_model_entry_serializes_correctly() {
        let entry = WebModelEntry {
            provider: "anthropic".to_string(),
            model: "claude-sonnet-4-6".to_string(),
            recommended: true,
        };
        let json = serde_json::to_string(&entry).expect("serialize");
        assert!(json.contains(r#""recommended":true"#));
        let parsed: WebModelEntry = serde_json::from_str(&json).expect("deserialize");
        assert_eq!(parsed, entry);
    }

    #[test]
    fn with_model_list_sets_catalog() {
        let adapter = WebAdapter::new(
            3210,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        )
        .with_model_list(vec![WebModelEntry {
            provider: "openai".to_string(),
            model: "gpt-4o".to_string(),
            recommended: true,
        }]);
        assert_eq!(adapter.model_list.len(), 1);
    }

    #[test]
    fn with_model_change_callback_sets_callback() {
        let adapter = WebAdapter::new(
            3210,
            "token".to_string(),
            "*".to_string(),
            "".to_string(),
            "shared-main".to_string(),
        )
        .with_model_change_callback(Arc::new(|_p, _m| {}));
        assert!(adapter.model_change_cb.is_some());
    }

    #[test]
    fn ws_message_cancel_generation_roundtrip() {
        let json = serde_json::to_string(&WsMessage::CancelGeneration).expect("serialize");
        assert!(json.contains(r#""type":"cancel_generation""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        assert!(matches!(parsed, WsMessage::CancelGeneration));
    }

    #[test]
    fn ws_message_generation_cancelled_roundtrip() {
        let json = serde_json::to_string(&WsMessage::GenerationCancelled).expect("serialize");
        assert!(json.contains(r#""type":"generation_cancelled""#));
        let parsed: WsMessage = serde_json::from_str(&json).expect("deserialize");
        assert!(matches!(parsed, WsMessage::GenerationCancelled));
    }
}
